### 第10章 函数

1. 函数实际上就是对象，每个函数都是Function类型的实例。

2. 箭头函数虽然好用，当参数没有，或者多个参数情况下才需要括号，一条参数或者一条操作、表达式可以不写括号，或者大括号。

    但它不能使用arguments、super、new.target，也不能用做构造函数，它也没有prototype属性。

3. 函数名就是指向函数对象的指针 （拷贝，引用，内存地址问题？）
#### 参数

1. 函数不关心你到底传了几个参数，可以是无、超过型参，或者不够，都不会报错，因为函数的参数在内部表现为一个数组,具体来说是一个类数组对象，再非箭头函数里，可以访问arguments对象，从而取得传进来的每一个参数值。`arguments[0]` 来访问第一个参数 .length可以看有多少个参数

2. 所有参数都是按值传递的，不可能按引用传递，如果把对象作为参数传递，那么传递的值就是这个对象的引用。

3. **函数重载问题** java中同一个函数名传的参数类型和数量不同是可以作为两个函数使用的，而js中后定义的会覆盖先定义的。 js中没有函数重载

4. **默认参数值** `function( name = 'foo')` 加上一个等于就是给参数默认值了。
    1. arguments不会影响，它始终以调用函数时传入的值为准，如果没传，但有默认参数，还是undefined。
    2. 函数的默认参数只有在函数被调用时才会求值，不会在函数定义时求值
    3. 箭头函数也可以使用默认参数，不过只有一个参数时不能省略括号了

5. **默认参数作用域和暂时性死区** 
    1. 因为在求值默认参数时可以定义对象，也可以动态调用函数，那么这个操作肯定是在某个作用域中求值的。这其实跟用let来顺序声明变量是一样的。<br>
    `function a(name = 'foo', age = '20'){ return ...}` <br>
    在这里参数的初始化是等同于<br>
    `function a(){let name = 'foo';let age = '20';return ...}`
    不能再次声明，会报错
    
    2. 因为是按顺序初始化的，所以后面一个参数是可以引用先定义的参数的。而且参数初始化遵循“暂时性死区”原则，先定义的参数不能调用后面定义的，会抛出错误。

6. ... 参数扩展 rest ，把不定量的参数表现为一个数组，这样就不需要arguments了 `(...变量名)`并且只能是最后一个参数，

7. 声明和表达式 

    1. 函数声明会在任何代码执行前被读取并添加到执行上下文，这叫函数声明提升（也就是说在执行代码时，js引擎会先执行一遍扫描，来把函数声明提升到顶部）

    ` console.log(sum())
      function sum(){} // 不会报错 这是函数声明
    ` 
    <br>
    `
    console.log(sum());
    let sum = function(){} //会报错 这是函数表达式
    `

    2. 两者除了在什么时候真正定义了有区别外，其余没什么不同，等价的

8. **函数内部**

    1. 在es5中，函数内部存在两个特殊的对象， arguments 和 this ，es6中新增了new.target属性

    2. **arguments.callee**  这个属性是一个指向arguments对象所在函数的指针，例如一个函数递归调用自己，这样可以做到让 函数名 和 函数逻辑 解耦，很实用的方法，这样函数名更改或者赋值给别人都不需要改里面了

    3. **this**

9. 闭包

10. this

11. **立即调用的函数表达式** 立即调用的 匿名函数 被称作为立即调用的函数表达式 IIFE，这可以模拟块级作用域，(function(){var a = 'foo'})() 外部是访问不到a的，es5 不支持块级作用域，所以可以用这个来模拟

    es6后 就不是那么必要了 let可以生成一个块级作用域，