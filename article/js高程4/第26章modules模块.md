### 模块

1. 普通的模块加载是阻塞的，必须先加载最深层被依赖的模块

2. 本地使用模块会使浏览器报错，跨域问题，需要搭个本地服务器来解决

> 你需要注意本地测试 —  如果你通过本地加载Html 文件 (比如一个 file:// 路径的文件), 你将会遇到 CORS 错误，因为Javascript 模块安全性需要。你需要通过一个服务器来测试。——MDN

为什么？
 file协议的问题，跨域限制是浏览器行为

3.commonJS和AMD是es6之前的模块加载，包括nodeJS的require都属于加载模块这个概念。 

4. `<script type="module" src="">`这里就向浏览器相关代码应该作为模块执行。

    与传统脚本不同，所有模块都会带上**defer**这个关键词来执行，这样解析到该标签会立即下载模块文件，但是执行会延迟到文档解析完成。如果有多个模块文件，出现顺序就是执行顺序，所以把script标签无论放在head或者body后，只会影响文件什么时候加载，而不会影响模块什么时候加载 而 **async** 也是支持的，只不过是谁先加载好谁执行

5. **导出 export** 

    1. es6模块支持两种 **命名导出** 和 **默认导出**

    2. 不同的导出方式对应着不同的导入方式

    3. **export**关键词用于声明一个值为命名导出，导出语句不能在某一个块中，必须在模块顶级。

        导出值对模块内部的js执行顺序没有直接影响，所以export出现顺序没有多大讲究。

        ```
        
        export const foo='foo'
        ``` 
        代表了声明的同时也导出
        （常用的封装api也是这么写的）

        导出时也可以提供别名，别名必须在export子句的大括号语法中指定，因此 声明值 导出值 为导出值提供别名不能在同一行完成。
        ```
        const foo='' 
        export {foo as myfoo}
        ```
    4. **默认导出** 需加上关键字 default 每一个模块只能有一个默认导出，重复会报错

        行内默认导出中不能出现变量声明

6. **导入 import**

    import必须出现在顶部，import语句也会被提升到模块顶部，虽说这样位置就不太重要，但是语义化来讲还是放在顶部。


7. 向后兼容 

    对于不支持es6的浏览器，要么使用babel等转译器，要么在写一段script放在下面，这样浏览器执行到module无法识别会拒绝执行，这时候下面的script就会被执行，但是，这样在支持es6的浏览器中，两个script标签都会被执行，解决方案是在下面一个script标签加上
    *nomodule*关键字，这样支不支持es6的浏览器都只会选一个script来执行


8. 所有代码都在模块作用域，不会污染全局作用域

模块模式是管理复杂性的永恒工具，可以创建逻辑彼此独立的代码段，在这中间声明依赖，并连接在一起